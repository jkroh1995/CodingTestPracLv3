#### 🔗 Link
https://school.programmers.co.kr/learn/courses/30/lessons/72413#

## 🤔 Think

 그래프 문제는 많이 풀어본 적이 없어 처음 접근이 어려웠습니다.
 
 단순 dfs 즉 재귀로 풀면 효율성 테스트에서 절대 통과하지 못 할 것이라고 생각했습니다.(최악의 경우 n이 200이면 효율성을 통과하지 못할 것이라 생각) 
 
 그래프 문제를 해결하기 위한 알고리즘은 다익스트라 알고리즘만 알고 있었는데, 해당 문제는 합승의 개념이 있어서 다익스트라 알고리즘을 적용하기 어렵다고 생각했습니다.
 
 접근 법을 알기 위해 다른 분들의 질문을 확인했는데 플로이드 - 워셜 알고리즘을 사용하시는 경우가 많아 해당 내용을 공부해볼 겸 사용해서 문제를 해결했습니다.
 
 다익스트라 알고리즘이 한 점에서 다른 모든 점까지의 최단거리를 계산한다면, 플로이드 - 워셜 알고리즘은 모든 점에서 다른 모든 점까지의 최단거리를 계산합니다.
 
 당연히 한 점 -> n개의 점이라는 차이가 생기기 때문에 기존의 다익스트라 알고리즘의 O(N^2) 에 O(N)만큼의 시간복잡도를 곱한 결과가 나옵니다. 즉, O(N^3)의 시간복잡도를 갖는 알고리즘입니다.

## 🔎 Solve

- 플로이드 - 워셜 알고리즘을 사용해 모든 점에서 다른 점까지의 최단 경로를 계산합니다.
- 합승을 하지 않은 경우를 기본 값으로 설정합니다.
  - 합승을 포함한 모든 경우에서 최소값을 찾아야 하기 때문에 기본 값을 합승을 하지 않은 경우로 설정하고 합승했을 경우를 생각하면 간단합니다.
  - (start -> A까지의 요금) + (start -> B까지의 요금)으로 계산할 수 있습니다.
- 합승을 한 경우의 요금을 계산해 이전 값과 비교합니다. 만일 값이 더 작으면 해당 값을 최종 요금으로 설정합니다.
  - 합승 시 요금은 (start -> 합승 하차 지점) + (합승 하차 지점 -> A까지의 요금) + (합승 하차 지점 -> B까지의 요금)으로 계산할 수 있습니다.
  - 이는, 플로이드 - 워셜 알고리즘을 통해 모든 점에서 모든 점까지의 비용을 미리 계산했기에 가능합니다.
