#### 🔗 Link
[https://school.programmers.co.kr/learn/courses/30/lessons/77485](https://school.programmers.co.kr/learn/courses/30/lessons/43105?language=java)

## 🤔 Think

단순한 DP 문제입니다. 모든 길을 DFS로 돌면 O(N!)만큼의 시간복잡도가 발생하지만, DP로 해결하면 O(N^2)만큼으로 해결할 수 있습니다.
- DFS가 O(N!)인 이유 : 각 칸마다 선택지가 1부터 1씩 증가해 마지막에는 n개의 선택지까지 이어집니다. 즉 1 * 2 * 3 * ... * (n-2) * (n-1) * n 의 경우의 수가 발생합니다.
- DP가 O(N^2)인 이유 : 전체 n 행이라고 할 때, 각 행을 한번씩 방문하고, 해당 행의 모든 경우를 한 번씩 순회합니다. 즉, 1번째 행의 1개의 숫자부터 n번째 행의 n개의 숫자까지 탐색하므로 O(N^2) 만큼의 시간복잡도가 발생합니다.

## 🔎 Solve

- 삼각형의 형태를 직각 삼각형의 형태로 분석합니다. 즉, 왼쪽으로 한 칸 이동하는 것은 자신의 바로 아래 위치의 원소를 방문한다고 이해할 수 있습니다.
![image](https://github.com/jkroh1995/CodingTestPracLv3/assets/85445649/8f8aad8f-b4fc-47bd-8a71-714ec2888086)
- 맨 위의 행렬부터 탐색을 시작합니다.
- 바로 아래 행렬을 돌기 전, 아래 행렬을 복사한 행렬을 하나 준비합니다.
- 위의 행렬에서 아래 행렬에 숫자를 더한 값을 복사한 행렬에 대입합니다.
- 이 때 겹치는 부분은 앞서 계산한 값보다 큰 값이 나중에 들어오면 해당 값으로 대체합니다.
- 최종적으로 만들어진 최하단 행렬에서 가장 큰 값을 반환합니다.

