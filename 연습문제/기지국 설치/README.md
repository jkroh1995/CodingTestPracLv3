#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/12979

## 🤔 Think
처음에는 n 크기 만큼의 배열을 만들고, stations를 순회하면서 w만큼씩 기지국을 직접 설치하는 방식을 사용하고자 했습니다. 이렇게 문제 풀이를 진행하면, 구현 자체는 쉬우나 효율성에서 통과하지 못 했습니다.

solutions 배열과 w의 크기는 10000이하입니다. 즉, solutions 배열의 크기를 length라고 할 때, 기존의 방법대로 하면 O(length * w)만큼의 시간 복잡도가 발생합니다. 최악의 경우 1억의 시간 복잡도가 발생하는 거죠.

그럼 어떻게 해야 O(N)의 시간복잡도를 갖는 로직으로 해결할 수 있을까. 다시 말해, 어떻게 stations를 한 차례만 돌면서 문제를 해결할 수 있을까를 고민했습니다.

방법만 생각하면 구현 자체는 크게 어렵지 않습니다. 알고리즘 문제라기엔 애매한 문제들이 레벨3에는 많네요.

## 🔎 Solve
- index로 접근해야 하기 때문에, stations에 기록된 기지국 번호를 1씩 줄여줍니다.
- 0번째 아파트 ~ 첫 번째 기지국의 왼쪽 끝의 범위에 세워야 하는 기지국의 수를 구해 답에 더합니다.
  - 이 때, 첫 번째 기지국이 0번째 아파트까지 커버한다면, 0을 반환합니다.
- n-1번째 기지국의 오른쪽 끝 ~ n번째 기지국의 왼쪽 끝의 범위에 세워야 하는 기지국의 수를 구해 답에 더합니다.
  - 이 때, 커버해야 하는 범위가 하나의 기지국으로 커버할 수 있는 범위로 나누어떨어지면 나눈 값을 더합니다.
  - 그렇지 않으면, 나눈 값에 1을 더한 값을 더합니다.
- 마지막 기지국의 오른쪽 끝 ~ 마지막 아파트의 범위에 세워야 하는 기지국의 수를 구해 답에 더합니다.
