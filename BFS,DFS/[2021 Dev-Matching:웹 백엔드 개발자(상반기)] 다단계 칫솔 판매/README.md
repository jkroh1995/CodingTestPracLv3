#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/77486

## 🤔 Think 
 DFS로 분류를 하기는 했는데 일반적인 DFS문제라고 보기는 어려워보이네요. 일반적인 DFS가 루트 노트에서 최하단 노드까지 탐색하는 문제라면, 이번 문제는 최하단 노드에서 루트 노드까지 역으로 타고 올라가는 문제입니다.

 역으로 타고 올라간다? 그럼 각 노드마다 연결을 하나씩만 생각하면 되는거 아닌가? 라는 생각이 들었습니다. 어짜피 역순으로 가도 결국 루트 노드까지는 도달할테고, 자기 부모 노드 하나만 알면 되니까요.

 그래서 생각한 구조가 맵으로 그래프를 표현하자는 것이었습니다. A - B - C - D의 구조를 A : B, B : C, C : D 의 형태로 나타내면 쉽고 효율적으로 구현이 가능할 것 같았습니다. 문제에서 요구하는 사항인 루트 노드에 도달하거나 금액이 0이 될 때까지 그래프를 타고 올라가는 거죠.

## 🔎 Solve
- <자식 : 부모> 형태의 맵을 만들고 채웁니다.
- <이름 : 판매금액> 형태의 맵을 만들고 [이름 : 0] 의 값을 채웁니다.
- 판매 배열을 순회하며 판매자 노드를 따라 올라갑니다.
  - 판매자 이름, 판매액을 기준으로 시작합니다.
  - 판매액 = 판매액 - 판매액*10/100 으로 설정합니다.
  - 2원은 그대로 2원이 되어야 합니다. 즉, 판매액*90/100의 형태는 되면 안됩니다.
  - 20원은 18원이 되어야합니다. 따라서 판매액 - 판매액/100*10의 형태는 되면 안됩니다.
  - <이름 : 판매금액> 형태의 맵에 [이름 : 기존 판매액 + 현재 판매액]을 넣습니다.
  - 이름에 <자식 : 부모> 맵에서 가져온 부모의 이름을 할당하고, 판매액에 판매액 * 10 / 100을 할당합니다.
  - 만일 이름이 " - "가 되거나 판매액이 0이 되면 해당 회차를 종료합니다.
- 이름 순서에 맞게 <이름 : 판매금액> 맵에서 판매금액을 가져와 정답 배열의 요소를 채웁니다.
